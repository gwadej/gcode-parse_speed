#!/usr/bin/env perl

use strict;
use warnings;
use 5.010;

use Dumbbench;

my $num_matches; # = 3;
my $file = shift || 'target/rose.gcode' ;

my @lines = do { open my $fh, '<', $file or die; <$fh> };
my ($iterations, $precision) = @lines < 1000 ? (50_000, 0.01) : (100, 0.005);
my $bench = Dumbbench->new(
  target_rel_precision => $precision,
  initial_runs         => $iterations,    # the higher the more reliable
);
$bench->add_instances(
    Dumbbench::Instance::PerlSub->new(name => 'naive',      code => \&naive_impl),
    Dumbbench::Instance::PerlSub->new(name => 'non-greedy', code => \&non_greedy_impl),
    Dumbbench::Instance::PerlSub->new(name => 'greedy',     code => \&greedy_impl),
    Dumbbench::Instance::PerlSub->new(name => 'args',       code => \&args_impl),
    Dumbbench::Instance::PerlSub->new(name => 'argstr',     code => \&argstr_impl),
    Dumbbench::Instance::PerlSub->new(name => 'substr',     code => \&substr_impl),
    Dumbbench::Instance::PerlSub->new(name => 'index',      code => \&index_impl),
);

$bench->run;
$bench->report;

sub naive_impl
{
    my ($line, $count) = ('', 0);
    for(@lines)
    {
        ($line, $count) = ($_, $count+1) if /^G1\b.*Z2\.\d00/;
    }
    say STDERR "Error naive ($count)" if defined $num_matches && $count != $num_matches;
    return;
}

sub non_greedy_impl
{
    my ($line, $count) = ('', 0);
    for(@lines)
    {
        ($line, $count) = ($_, $count+1) if /^G1(?![\d.]).*?Z2\.\d00(?!\d)/;
    }
    say STDERR "Error non-greedy ($count)" if defined $num_matches && $count != $num_matches;
    return;
}

sub greedy_impl
{
    my ($line, $count) = ('', 0);
    for(@lines)
    {
        ($line, $count) = ($_, $count+1) if /^G1(?![\d.]).*Z2\.\d00(?!\d)/;
    }
    say STDERR "Error greedy ($count)" if defined $num_matches && $count != $num_matches;
    return;
}

sub args_impl
{
    my ($line, $count) = ('', 0);
    for(@lines)
    {
        next unless /^G1(?![\d.]).*?Z([\d.]+)/;
        next unless 2.0 <= $1 && $1 < 3.0;
        ($line, $count) = ($_, $count+1);
    }
    say STDERR "Error args ($count)" if defined $num_matches && $count != $num_matches;
    return;
}

sub argstr_impl
{
    my ($line, $count) = ('', 0);
    for(@lines)
    {
        next unless /^G1(?![\d.]).*?Z([\d.]+)/;
        next unless '2.0' le $1 && $1 lt '3.0';
        ($line, $count) = ($_, $count+1);
    }
    say STDERR "Error args ($count)" if defined $num_matches && $count != $num_matches;
    return;
}

sub substr_impl
{
    my ($line, $count, $match, $pos) = ('', 0, '', 0);
    for(@lines)
    {
        next unless substr( $_, 0, 2) eq 'G1';
        $match = substr( $_, 2, 1 );
        next if '0' le $match && $match le '9';
        next if -1 == ($pos = index( $_, 'Z2.', 3 ));
        $match = substr( $_, $pos+3, 1);
        next unless '0' le $match && $match le '9';
        next unless substr( $_, $pos+4, 2 ) eq '00';
        $match = substr( $_, $pos+6, 1);
        next if '0' le $match && $match le '9';
        ($line, $count) = ($_, $count+1);
    }
    say STDERR "Error substr ($count)" if defined $num_matches && $count != $num_matches;
    return;
}

sub index_impl
{
    my ($line, $count, $match, $pos) = ('', 0, '', 0);
    for(@lines)
    {
        next unless 0 == index( $_, 'G1' );
        $match = substr( $_, 2, 1 );
        next if '0' le $match && $match le '9';
        next if -1 == ($pos = index( $_, 'Z2.', 3 ));
        $match = substr( $_, $pos+3, 1);
        next unless '0' le $match && $match le '9';
        next unless substr( $_, $pos+4, 2 ) eq '00';
        $match = substr( $_, $pos+6, 1);
        next if '0' le $match && $match le '9';
        ($line, $count) = ($_, $count+1);
    }
    say STDERR "Error index ($count)" if defined $num_matches && $count != $num_matches;
    return;
}
